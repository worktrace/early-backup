import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:meta/meta.dart';
import 'package:meta/meta_meta.dart';
import 'package:source_gen/source_gen.dart';

/// Define how to generate data from an annotation of specified type [T].
///
/// This abstract class is usually used as a parameter of certain [Generator]
/// extends [AnnotationGeneratorBase]. It's not a [Generator] itself,
/// or something like the [GeneratorForAnnotation] abstract class.
/// And it works on a single parsed annotated element rather than a library.
abstract class GeneratorOnAnnotation<T> {
  const GeneratorOnAnnotation();

  /// Define how to check the type [T].
  TypeChecker get typeChecker => TypeChecker.fromRuntime(T);

  /// How to build on a single annotation of type [T].
  String build(Element element, ConstantReader annotation, BuildStep buildStep);

  /// Check type and build when necessary.
  ///
  /// 1. When there's multiple annotation with the same specified type [T],
  /// or match the override [typeChecker] rule, it will only use the first one.
  /// 2. When there's nothing to build, it will return null.
  /// 3. It's strongly not recommended to override this method directly.
  /// You may consider override the [build] method or the [typeChecker] getter.
  @protected
  String? maybeBuild(
    Element element,
    BuildStep buildStep, {
    bool throwOnUnresolved = true,
  }) {
    final result = typeChecker.firstAnnotationOf(
      element,
      throwOnUnresolved: throwOnUnresolved,
    );
    if (result == null) return null;
    return build(element, ConstantReader(result), buildStep);
  }
}

abstract class AnnotationGeneratorBase extends Generator {
  const AnnotationGeneratorBase({this.throwOnUnresolved = true});

  final bool throwOnUnresolved;

  /// Define how to generate from a [library].
  ///
  /// 1. Return `null` to indicate there's nothing to generate.
  /// 2. When the returned value is not null, it will generate such file.
  /// 3. This method is just a shell for encapsulation.
  /// You may consider override [joinResults] or [generateAll].
  @protected
  @override
  String? generate(LibraryReader library, BuildStep buildStep) {
    final results = generateAll(library, buildStep);
    return results.isEmpty ? null : joinResults(results, library, buildStep);
  }

  /// Define how to join results generated by each annotation.
  @protected
  String joinResults(
    Iterable<String> results,
    LibraryReader library,
    BuildStep buildStep,
  ) => results.join('\n\n');

  /// Encapsulations of generating all annotations.
  ///
  /// 1. Usually only be called inside the [generate] method.
  /// 2. It's more recommended to override the [generate] or [joinResults]
  /// method rather than this one in most cases.
  @protected
  Iterable<String> generateAll(LibraryReader library, BuildStep buildStep);
}

/// Generate for top level annotations only.
///
/// 1. Faster than [RecursiveAnnotationGenerator].
/// 2. Optimization over the raw [GeneratorForAnnotation] implementation,
/// which is simpler and more efficient, but less extendable,
/// that it does not allow async generating.
abstract class TopLevelAnnotationGenerator<T> extends AnnotationGeneratorBase {
  const TopLevelAnnotationGenerator({super.throwOnUnresolved});

  TypeChecker get typeChecker => TypeChecker.fromRuntime(T);

  /// Encapsulations of generating all annotations.
  ///
  /// 1. Usually only be called inside the [generate] method.
  /// 2. It's more recommended to override the [generate] method
  /// rather than this one in most cases.
  @override
  Iterable<String> generateAll(LibraryReader library, BuildStep buildStep) {
    final b = buildStep;
    return library
        .annotatedWith(typeChecker, throwOnUnresolved: throwOnUnresolved)
        .map((i) => generateForAnnotatedElement(i.element, i.annotation, b));
  }

  /// Generate code from a single annotation.
  String generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  );
}

/// Generate recursively from multiple [GeneratorOnAnnotation]s.
///
/// If your generating strategy is simple enough and works like
/// the raw [GeneratorForAnnotation],
/// you may consider [TopLevelAnnotationGenerator], which is more efficient.
/// This generator will recursively process all children elements of a library.
abstract class RecursiveAnnotationGenerator extends AnnotationGeneratorBase {
  const RecursiveAnnotationGenerator({super.throwOnUnresolved});

  Iterable<GeneratorOnAnnotation<dynamic>> get generators;

  @override
  Iterable<String> generateAll(LibraryReader library, BuildStep buildStep) {
    return generateRootElement(
      library.element,
      buildStep,
      throwOnUnresolved: throwOnUnresolved,
    );
  }

  /// Generate code recursively based on the root [element] of a library.
  ///
  /// The root [element] is supposed to be at the root of a library
  /// (from a [LibraryReader]).
  /// The annotation of the [element] itself will not be recognized here.
  /// It will only process the children layer, and recursive when necessary.
  @protected
  Iterable<String> generateRootElement(
    Element element,
    BuildStep buildStep, {
    bool throwOnUnresolved = true,
  }) sync* {
    for (final child in element.children) {
      for (final generator in generators) {
        final result = generator.maybeBuild(
          child,
          buildStep,
          throwOnUnresolved: throwOnUnresolved,
        );
        if (result != null) yield result;
      }
      yield* generateRootElement(
        child,
        buildStep,
        throwOnUnresolved: throwOnUnresolved,
      );
    }
  }
}

/// Throw when the annotation position is invalid.
///
/// The valid position of an annotation should be indicated by the [Target]
/// annotation provided by `package:meta`.
/// And it is supposed to be check before using the parsed [Element]
/// and assert the type of the source element.
class AnnoPosException implements Exception {
  const AnnoPosException();

  @override
  String toString() => 'invalid annotation position';
}
