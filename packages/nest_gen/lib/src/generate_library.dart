import 'package:build/build.dart';
import 'package:meta/meta.dart';
import 'package:source_gen/source_gen.dart';

/// A generator that will generate according to multiple components.
abstract class ComposedGenerator extends Generator {
  const ComposedGenerator();

  /// Define how to generate from a [library].
  ///
  /// 1. Return `null` to indicate there's nothing to generate.
  /// 2. When the returned value is not null, it will generate such file.
  /// 3. This method is just a shell for encapsulation.
  /// 4. It's strongly not recommended to override this method:
  /// consider overriding [generateComponents] and [joinComponents] instead.
  @override
  String? generate(LibraryReader library, BuildStep buildStep) {
    final results = generateComponents(library, buildStep);
    return results.isEmpty ? null : joinComponents(results, library, buildStep);
  }

  /// Define how to join results generated by each annotation.
  @protected
  String joinComponents(
    Iterable<String> results,
    LibraryReader library,
    BuildStep buildStep,
  ) => results.join('\n\n');

  /// How to generate all components inside according to current library.
  ///
  /// The return value of this method is supposed to be
  /// an iterable strings of all generated components,
  /// and an empty iterable indicates there's nothing to generate.
  ///
  /// This method is an encapsulation over the [generate] method,
  /// which will be called by the builder,
  /// and the [joinComponents] method helps to define
  /// how to join all generated components.
  @protected
  Iterable<String> generateComponents(
    LibraryReader library,
    BuildStep buildStep,
  );
}
